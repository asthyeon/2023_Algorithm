import sys
sys.stdin = open('input.txt')
input = sys.stdin.readline

"""
# 모든 전깃줄이 교차하지 않게 하기 위해 없애야 하는 전깃줄의 최소 개수 구하기
1. 위치의 번호는 500 이하의 자연수
2. 전깃줄의 개수는 100 이하의 자연수
@ 풀이
(1) 경우의 수(A를 오름차순으로 만들고 가능한 전깃줄 개수를 구하기)
(2) 가장 긴 수열을 구하는 것과 같음
A = [1]
B = [8]
길이 1 
A = [1, 2]
B = [8, 2]
길이 1  1
A = [1, 2, 3]
B = [8, 2, 9]
길이 1  1  2
A = [1, 2, 3, 4]
B = [8, 2, 9, 1]
길이 1  1  2  2
A = [1, 2, 3, 4, 6]
B = [8, 2, 9, 1, 4]
길이 1  1  2  2  2
A = [1, 2, 3, 4, 6, 7]
B = [8, 2, 9, 1, 4, 6]
길이 1  1  2  2  2  3
A = [1, 2, 3, 4, 6, 7, 9]
B = [8, 2, 9, 1, 4, 6, 7]
길이 1  1  2  2  2  3  4
A = [1, 2, 3, 4, 6, 7, 9, 10]
B = [8, 2, 9, 1, 4, 6, 7, 10]
길이 1  1  2  2  2  3  4  5
(3) 전체 전깃줄에서 가능한 전깃줄을 빼기
"""


# dp 함수
def dp(N, AB):
    dp = [0] * (N + 1)
    
    # 최대로 전기줄이 존재할 수 있는 수를 구하기
    for j in range(1, N + 1):
        # 기본 값 부여
        dp[j] = 1
        for k in range(1, j + 1):
            # 이전 수보다 현재 수가 더 크다면
            if AB[j][1] > AB[k][1]:
                # 현재까지 비교한 수중 가장 큰 길이와 이전의 길이랑 비교 후 교체
                dp[j] = max(dp[j], dp[k] + 1)
    
    # 최대 전기줄에서 존재할 수 있는 전기줄 수를 빼면 제거해야할 수가 나옴
    return N - max(dp)


# 전깃줄의 개수: N
N = int(input())

# 전깃줄 연결 현황
AB = []
for i in range(1, N + 1):
    x, y = map(int, input().split())
    AB.append((x, y))

# A 기준으로 정렬
AB.sort()

# 인덱스 조정
AB.insert(0, (0, 0))

print(dp(N, AB))