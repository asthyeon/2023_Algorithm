import sys
sys.stdin = open('input.txt')
input = sys.stdin.readline

"""
# 총 점수의 최댓값 구하기
1. 한 번에 1계단씩 혹은 2계단 가능
2. 연속된 세 개의 계단을 밟을 수 없음
3. 시작점은 계단에 포함 X
4. 마지막 도착 계단은 반드시 밟기
@풀이
(1) DP로 풀기
(2) 1칸 오르면 다음칸과 다다음칸 중 큰 값 고르기
(2) 경우의 수
[10, 20]

1. 1칸(10), 2칸(20)

[10, 20, 15]

1. 1칸(10), 3칸(15) = 25
2. 2칸(20), 3칸(15) = 35

[10, 20, 15, 25]

1. 1칸(10), 3칸(15), 4칸(25) = 50
2. 2칸(20), 4칸(25) = 45

[10, 20, 15, 25, 10]

1. 1칸(10), 2칸(20), 4칸(25), 5칸(10) = 65
2. 1칸(10), 3칸(15), 5칸(10) = 35
3. 2칸(20), 3칸(15), 5칸(10) = 45
4. 2칸(20), 4칸(25), 5칸(10) = 55

[10, 20, 15, 25, 10, 20]

1. 1칸(10), 2칸(20), 4칸(25), 6칸(20) = 75
2. 1칸(10), 3칸(15), 4칸(25), 6칸(20) = 70
3. 1칸(10), 3칸(15), 5칸(10), 6칸(20) = 55
4. 2칸(20), 3칸(15), 5칸(10), 6칸(20) = 65
5. 2칸(20), 4칸(25), 6칸(20) = 65
"""


# dp 함수
def dp(T):
    dp = [0] * (T + 1)
    # 1칸, 2칸은 미리 계산하기
    dp[1] = stair[1]
    if T >= 2:
        dp[2] = stair[1] + stair[2]
    # 3칸 이상일 때 그 칸에 도달했을 때 더 큰 값으로 바꿔주기
    if T >= 3:
        for i in range(3, T + 1):
            # dp: 이전까지 밟아온 칸, stair: 새로 밟을 칸
            # 앞부분은 2칸 남았을 때 3칸 연속이 불가능하기에 2칸 전진
            # 뒷부분은 3칸 남았을 때 2칸 전진후, 1칸 더 전진
            dp[i] = max(dp[i - 2] + stair[i], dp[i - 3] + stair[i - 1] + stair[i])
    # 가장 마지막값 출력
    return dp[T]


# 계단의 개수: T
T = int(input())

# 계단 만들기(0은 인덱스를 용이하게 맞추기 위함)
stair = [0]
for _ in range(T):
    stair.append(int(input()))

print(dp(T))
