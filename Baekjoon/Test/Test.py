import sys
sys.stdin = open('input.txt')
input = sys.stdin.readline

"""
# 달에 도달하기 위해 필요한 연료의 최소값 계산
1. 지구와 우주사이는 N x M 행렬
2. 각 원소의 값은 우주선이 그 공간을 지날 때 소모되는 연료양
3. 지구 -> 달로 가는 경우 우주선이 움직일 수 있는 방향: 왼쪽아래, 아래, 오른쪽아래
4. 우주선은 전에 움직인 방향으로 움직일 수 없음(같은 방향 두번 연속 불가)
5. 지구의 어느위치든 출발하여 달의 어느위치든 착륙
@ 풀이
(1) dp 로 풀기
  y
x 5  8  5  1
  3  5  8  4
  9  77 65 5
  2  1  5  2
  5  98 1  5
  4  95 67 58
(2) 방향도 넣어서 3차원 배열 구현
왼쪽 위에서 넘어올 때 = 0
바로 위에서 넘어올 때 = 1
오른쪽 위에서 넘어올 때 = 2
"""


# dp 함수
def dp(N, M, arr):
    dp = [[[0] * 3 for _ in range(M)] for _ in range(N)]

    # 첫 줄은 그대로 입력
    for i in range(M):
        # 모든 방향을 그대로 넣기
        for k in range(3):
            dp[0][i][k] = arr[0][i]

    # 두번째 줄부터
    for m in range(1, N):
        for n in range(M):
            # n 이 0 일 때 왼쪽 위에서 올 수 없음
            if n == 0:
                # 바로 위에서 왔을 때
                # (오른쪽 위에서 넘어온 바로 위 수 -> 해당 수)
                dp[m][n][1] = dp[m - 1][n][2] + arr[m][n]
                # 오른쪽 위에서 왔을 때
                # (왼쪽 위에서 넘어온 오른쪽 위 수 -> 해당 수),
                # (바로 위에서 넘어온 오른쪽 위 수 -> 해당 수)
                dp[m][n][2] = min(dp[m - 1][n + 1][0] + arr[m][n], dp[m - 1][n + 1][1] + arr[m][n])
            # n 이 마지막 일 때 오른쪽 위에서 올 수 없음
            elif n == (M - 1):
                # 왼쪽 위에서 왔을 때
                # (바로 위에서 넘어온 왼쪽 위 수 -> 해당 수),
                # (오른쪽 위에서 넘어온 왼쪽 위 수 -> 해당 수)
                dp[m][n][0] = min(dp[m - 1][n - 1][1] + arr[m][n], dp[m - 1][n - 1][2] + arr[m][n])
                # 바로 위에서 왔을 때
                # (왼쪽 위에서 넘어온 바로 위 수 -> 해당 수)
                dp[m][n][1] = dp[m - 1][n][0] + arr[m][n]
            # 그 외 일 때
            else:
                # 왼쪽 위에서 왔을 때
                # (바로 위에서 넘어온 왼쪽 위 수 -> 해당 수),
                # (오른쪽 위에서 넘어온 왼쪽 위 수 -> 해당 수)
                dp[m][n][0] = min(dp[m - 1][n - 1][1] + arr[m][n], dp[m - 1][n - 1][2] + arr[m][n])
                # 바로 위에서 왔을 때
                # (왼쪽 위에서 넘어온 바로 위 수 -> 해당 수),
                # (오른쪽 위에서 넘어온 바로 위 수 -> 해당 수)
                dp[m][n][1] = min(dp[m - 1][n][0] + arr[m][n], dp[m - 1][n][2] + arr[m][n])
                # 오른쪽 위에서 왔을 때
                # (왼쪽 위에서 넘어온 오른쪽 위 수 -> 해당 수),
                # (바로 위에서 넘어온 오른쪽 위 수 -> 해당 수)
                dp[m][n][2] = min(dp[m - 1][n + 1][0] + arr[m][n], dp[m - 1][n + 1][1] + arr[m][n])

    # 최소값 출력을 위해 마지막 행의 첫번째 값과 마지막 값 최대값으로 교체
    dp[N - 1][0][0] = 600
    dp[N - 1][M - 1][2] = 600

    # 최소값 찾기
    result = 600
    for k in dp[N - 1]:
        if result > min(k):
            result = min(k)

    return result


# 행렬 크기 N x M
N, M = map(int, input().split())

# 각 행렬의 원소 값
arr = [list(map(int, input().split())) for _ in range(N)]

print(dp(N, M, arr))